;; Tom Murray
;; TMURRAY5

;; testAdd.asm
;; This file test the add reg and add imm5 instructions


SEGMENT  CodeSegment:
	;; R0 is assumed to contain zero, because of the construction
	;;    of the register file.  (After reset, all registers contain
	;;    zero.)

	;; R1 holds 1
	;; R2 holds 2
	;; R3 holds 1 + 2 = 3 then -1 + -2 = -3 (0xFFFD)
	;; R4 holds 3 + 1 = 4 then -3 + -1 = -4 (OXFFFC)
	;; R6 

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;Positve input tests
;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;Initialize constants
    LDR  R1, R0, ONE
    LDR  R2, R0, TWO

;;Test Add reg
    ADD  R3, R2, R1    

;;Test Add imm5
    ADD  R4, R3, 1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;Negative input tests
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;Initialize constants
    LDR  R1, R0, MINUS_ONE
    LDR  R2, R0, MINUS_TWO

;;Test Add reg
    ADD  R3, R2, R1

;;Test Add imm5
    ADD  R4, R3, -1


HALT:				; Infinite loop to keep the processor
    BRnzp HALT			; from trying to execute the data below
				; Your own programs should also make use
				; of an infinite loop at the end.

ONE:		DATA2 4x0001
TWO:		DATA2 4x0002
MINUS_ONE:	DATA2 4xFFFF
MINUS_TWO:	DATA2 4xFFFE


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; testAnd.asm
;; This file test the add reg and add imm5 instructions


SEGMENT  CodeSegment:
	;; R0 is assumed to contain zero, because of the construction
	;;    of the register file.  (After reset, all registers contain
	;;    zero.)

	;; R1 holds 0x0001
	;; R2 holds 0x00FF
	;; R3 holds 1 & 0x000F = 1 then 0xFFF0 & 0x000F = 0
	;; R4 holds 0x0001 & 0x000F = 1 then 0xFFF0 & 0x000F = 0 
;;;;;;;;;;;;;;;;;;;;;
;;Successful AND
;;;;;;;;;;;;;;;;;;;;;
;;Initialize constants
    LDR  R1, R0, ONE
    LDR  R2, R0, BIT_MASK

;;Test Add reg
    AND  R3, R2, R1    

;;Test Add imm5
    AND  R4, R3, 15

;;;;;;;;;;;;;;;;;;;;;;
;;Unsuccessful AND
;;;;;;;;;;;;;;;;;;;;;;
;;Initialize constants
    LDR  R1, R0, BIT_MASK
    LDR  R2, R0, BIT_MASK2

;;Test Add reg
    AND  R3, R2, R1

;;Test Add imm5
    AND  R4, R2, 15 


HALT:				; Infinite loop to keep the processor
    BRnzp HALT			; from trying to execute the data below
				; Your own programs should also make use
				; of an infinite loop at the end.

ONE:		DATA2 4x0001
BIT_MASK:	DATA2 4x000F
BIT_MASK2:	DATA2 4xFFF0


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; testJmp.asm
;; This file test the functionality of JMP as well as RET


SEGMENT  CodeSegment:
	;; R0 is assumed to contain zero, because of the construction
	;;    of the register file.  (After reset, all registers contain
	;;    zero.)

	;; R1 holds one
	;; R2 holds one
	;; R3 holds place to jump to
	;; R7 holds return address 


    LDR  R1, R0, ONE
    
    LDR  R3, R0, JUMP_LENGTH
    JMP  R3

HALT:				; Infinite loop to keep the processor
    BRnzp HALT			; from trying to execute the data below
				; Your own programs should also make use
				; of an infinite loop at the end.

    ;; adding no ops
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0

    ;; jump to here hopefully
    LDR  R2, R0, ONE
    LDR  R7, R0, RET_LENGTH
    RET

ONE:		DATA2 4x0001
JUMP_LENGTH:	DATA2 4x001D
RET_LENGTH:	DATA2 4x0006


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; testJsr.asm
;; This file test the functionality of JSR and JSRR as well as RET


SEGMENT  CodeSegment:
	;; R0 is assumed to contain zero, because of the construction
	;;    of the register file.  (After reset, all registers contain
	;;    zero.)

	;; R1 holds one
	;; R2 holds one
	;; R3 holds place to jsrr to
	;; R7 holds return address 


    LDR  R1, R0, ONE
    
    JSR  JSR_TEST

    LDR  R3, R0, JUMP_LENGTH
    JSRR R3
HALT:				; Infinite loop to keep the processor
    BRnzp HALT			; from trying to execute the data below
				; Your own programs should also make use
				; of an infinite loop at the end.

    ;; adding no ops
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0

    ;; first jump to here hopefully
JSR_TEST:
    LDR  R2, R0, ONE
    RET

    ;; then jump to here maybe
    LDR  R4, R0, ONE
    RET

ONE:		DATA2 4x0001
JUMP_LENGTH:	DATA2 4x0023


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; testLdb.asm
;; This file test the functionality of LDB and STB instructions


SEGMENT  CodeSegment:

    LDB  R6, R0, LowByte	;0
    	;MAR <= 8
        ;MDR <= (M[8] = 4x600D)
	;R6 <= 4x00 & 4x0D
    LDB  R7, R0, HighByte 	;2
	;MAR <= 8 or 9
	;MDR <= (M[8] = 4x600D)
	;R7 <= 4x00 & 4x60
    STB  R6, R0, LowSByte	;4
    	;MAR <= 10
        ;MDR <= 4xXX & (R6(7:0) = 4x0D)
	;M[10] = 4x0D
    STB  R7, R0, HighSByte	;6
    	;MAR <= 10 or 11
        ;MDR <= (R7(7:0) = 4x60) & 4xXX
	;*only* MWRITEH_L is active (=0).
	;M[11] = 4x60
Halt:
    BRnzp Halt

    LowByte: Data1 4x0D ;8
    HighByte: Data1 4x60 ;9
    LowSByte: Data1 ?	;10
    HighSByte: Data1 ? ;11

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; testLdi.asm
;; This file test the functionality of LDI and STI instructions


SEGMENT  CodeSegment:

; Test LDI, STI
    ldi r7, r0, MyPointer 
	;PC= 0
	;First load should see 
	;MAR <= 4 ;MDR <=(M[4] =6) 
	;Second load should see 
	;MAR <= 6 
	;MDR <= (M[6] = 4x600D) 
	;R7 <= 4x600D 
    sti r7, r0, MySPointer 
	;PC= 2 ;First load should see 
	;MAR <= 8 
	;MDR <= (M[8] = 4xA) 
	;Second store should see 
	;MAR <= 4xA 
	;MDR <= (R7 = 4x600D) 
	;M[10] <= 4x600D

Halt:
    BRnzp Halt
 
    MyPointer: DATA2 MyData ;4 
    MyData: DATA2 4x600D ;6 
    MySpointer: DATA2 MySData ;8 
    MySData: DATA2 ? ;10

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; testLeaNot.asm
;; This file test the functionality of LEA and NOT instruction


SEGMENT  CodeSegment:
	;; R0 is assumed to contain zero, because of the construction
	;;    of the register file.  (After reset, all registers contain
	;;    zero.)

	;; R1 holds 4 because PC = 2 + (1 << 1 = 2) = 4
	;; R2 holds not(0x0004) = 0xFFFB


    LEA  R1, 1
    NOT  R2, R1
    
HALT:				; Infinite loop to keep the processor
    BRnzp HALT			; from trying to execute the data below
				; Your own programs should also make use
				; of an infinite loop at the end.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; testShf.asm
;; This file test the functionality of SHF instruction


SEGMENT  CodeSegment:
	;; R0 is assumed to contain zero, because of the construction
	;;    of the register file.  (After reset, all registers contain
	;;    zero.)

;Initialize constants
    LDR   R1, R0, ONE
    LDR   R2, R0, MINUS_ONE
    LDR   R3, R0, NEGATIVE


    LSHF  R4, R1, 3 	; R4 <- R1 << 3 = 8
    RSHFL R5, R2, 8 	; R5 <- R2 >> 8,0 = 0x00FF
    RSHFA R6, R2, 8 	; R6 <- R2 >> 8,R2[15] = 0xFFFF
    RSHFA R7, R3, 3	; R7 <- R1 >> 1,R3[15] = 0xF000

HALT:				; Infinite loop to keep the processor
    BRnzp HALT			; from trying to execute the data below
				; Your own programs should also make use
				; of an infinite loop at the end.

ONE:		DATA2 4x0001
MINUS_ONE:	DATA2 4xFFFF
NEGATIVE:	DATA2 4x8000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; testShf.asm
;; This file test the functionality of TRAP instruction


SEGMENT  CodeSegment:
	;; R0 is assumed to contain zero, because of the construction
	;;    of the register file.  (After reset, all registers contain
	;;    zero.)

    LDR R1, R0, ONE

    TRAP cagey

HALT:				; Infinite loop to keep the processor
    BRnzp HALT			; from trying to execute the data below
				; Your own programs should also make use
				; of an infinite loop at the end.

; Insert NO Ops
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0

cagey:  DATA2 Weasel

; Insert NO Ops
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0
    ADD  R0, R0, R0



Weasel:
    ADD  R3, R1, R0
    RET


ONE:		DATA2 4x0001
