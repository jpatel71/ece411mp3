-- VHDL Entity ece411.arbiterControl.interface
--
-- Created:
--          by - tmurray5.stdt (eelnx39.ews.illinois.edu)
--          at - 16:43:41 11/16/10
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2005.3 (Build 75)
--
LIBRARY ieee;
USE ieee.NUMERIC_STD.all;
USE ieee.std_logic_1164.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;

ENTITY arbiterControl IS
   PORT( 
      D_ACCESS         : IN     STD_LOGIC;
      I_ACCESS         : IN     STD_LOGIC;
      PM_MRESP_H       : IN     STD_LOGIC;
      PM_READ_SEL_OUT  : IN     STD_LOGIC;
      PM_WRITE_SEL_OUT : IN     STD_LOGIC;
      clk              : IN     std_logic;
      reset_l          : IN     std_logic;
      PM_MREAD_L       : OUT    STD_LOGIC;
      PM_MWRITE_L      : OUT    STD_LOGIC;
      sel              : OUT    std_logic
   );

-- Declarations

END arbiterControl ;

--
-- VHDL Architecture ece411.arbiterControl.fsm
--
-- Created:
--          by - tmurray5.stdt (eelnx39.ews.illinois.edu)
--          at - 16:43:41 11/16/10
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2005.3 (Build 75)
--
LIBRARY ieee;
USE ieee.NUMERIC_STD.all;
USE ieee.std_logic_1164.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;
 
ARCHITECTURE fsm OF arbiterControl IS

   TYPE STATE_TYPE IS (
      Init,
      I_MISS,
      D_Miss
   );
 
   -- State vector declaration
   ATTRIBUTE state_vector : string;
   ATTRIBUTE state_vector OF fsm : ARCHITECTURE IS "current_state";

   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      clk
   )
   -----------------------------------------------------------------
   BEGIN
      IF (clk'EVENT AND clk = '1') THEN
         current_state <= next_state;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      D_ACCESS,
      I_ACCESS,
      PM_MRESP_H,
      current_state
   )
   -----------------------------------------------------------------
   BEGIN
      CASE current_state IS
         WHEN Init => 
            IF (D_ACCESS = '1') THEN 
               next_state <= D_Miss;
            ELSIF (I_ACCESS = '1') THEN 
               next_state <= I_MISS;
            ELSE
               next_state <= Init;
            END IF;
         WHEN I_MISS => 
            IF (PM_MRESP_H = '1') THEN 
               next_state <= Init;
            ELSE
               next_state <= I_MISS;
            END IF;
         WHEN D_Miss => 
            IF (PM_MRESP_H = '1') THEN 
               next_state <= Init;
            ELSE
               next_state <= D_Miss;
            END IF;
         WHEN OTHERS =>
            next_state <= Init;
      END CASE;
   END PROCESS nextstate_proc;
 
   -----------------------------------------------------------------
   output_proc : PROCESS ( 
      PM_READ_SEL_OUT,
      PM_WRITE_SEL_OUT,
      current_state
   )
   -----------------------------------------------------------------
   BEGIN
      -- Default Assignment
      PM_MREAD_L <= '1';
      PM_MWRITE_L <= '1';
      sel <= '1';

      -- Combined Actions
      CASE current_state IS
         WHEN I_MISS => 
            sel <= '1';
            PM_MREAD_L <= PM_READ_SEL_OUT after 1ns;
            PM_MWRITE_L <= PM_WRITE_SEL_OUT after 1ns;
         WHEN D_Miss => 
            sel <= '0';
            PM_MREAD_L <= PM_READ_SEL_OUT after 1ns;
            PM_MWRITE_L <= PM_WRITE_SEL_OUT after 1ns;
         WHEN OTHERS =>
            NULL;
      END CASE;
   END PROCESS output_proc;
 
END fsm;
