-- VHDL Entity ece411.Cache_Datapath.interface
--
-- Created:
--          by - tmurray5.stdt (eelnx37.ews.illinois.edu)
--          at - 15:42:48 10/14/10
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2005.3 (Build 75)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;

ENTITY Cache_Datapath IS
   PORT( 
      ADDRESS      : IN     LC3b_word;
      Clk          : IN     std_logic;
      DATAOUT      : IN     LC3b_word;
      MREAD_L      : IN     std_logic;
      MWRITEH_L    : IN     std_logic;
      MWRITEL_L    : IN     std_logic;
      PMDATAIN     : IN     lc3b_oword;
      RESET_L      : IN     std_logic;
      in_idleHit   : IN     std_logic;
      in_load      : IN     std_logic;
      in_writeback : IN     std_logic;
      DATAIN       : OUT    lc3b_word;
      MRESP_H      : OUT    std_logic;
      PMADDRESS    : OUT    LC3B_WORD;
      PMDATAOUT    : OUT    lc3b_oword;
      dirty        : OUT    std_logic;
      hit          : OUT    std_logic;
      miss         : OUT    std_logic
   );

-- Declarations

END Cache_Datapath ;

--
-- VHDL Architecture ece411.Cache_Datapath.struct
--
-- Created:
--          by - tmurray5.stdt (eelnx37.ews.illinois.edu)
--          at - 15:42:49 10/14/10
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2005.3 (Build 75)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;

LIBRARY ece411;

ARCHITECTURE struct OF Cache_Datapath IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL AccessOut      : std_logic;
   SIGNAL Index          : LC3b_index;
   SIGNAL LRUOut         : std_logic;
   SIGNAL WaySelecterOut : LC3B_oWORD;
   SIGNAL b              : LC3b_word;
   SIGNAL dataOut0       : lc3b_oword;
   SIGNAL dataOut1       : lc3b_oword;
   SIGNAL delayOut       : std_logic;
   SIGNAL dirtyIn0       : std_logic;
   SIGNAL dirtyIn1       : std_logic;
   SIGNAL dirtyOut0      : std_logic;
   SIGNAL dirtyOut1      : std_logic;
   SIGNAL dirtyWrite0    : std_logic;
   SIGNAL dirtyWrite1    : std_logic;
   SIGNAL f              : lc3b_oword;
   SIGNAL f1             : std_logic;
   SIGNAL f2             : std_logic;
   SIGNAL f3             : std_logic;
   SIGNAL f4             : std_logic;
   SIGNAL f6             : std_logic;
   SIGNAL f7             : std_logic;
   SIGNAL hitgate        : std_logic;
   SIGNAL line0          : lc3b_word;
   SIGNAL line1          : lc3b_word;
   SIGNAL line2          : lc3b_word;
   SIGNAL line3          : lc3b_word;
   SIGNAL line4          : lc3b_word;
   SIGNAL line5          : lc3b_word;
   SIGNAL line6          : lc3b_word;
   SIGNAL line7          : lc3b_word;
   SIGNAL lineDataOut0   : lc3b_word;
   SIGNAL lineDataOut1   : lc3b_word;
   SIGNAL lineDataOut2   : lc3b_word;
   SIGNAL lineDataOut3   : lc3b_word;
   SIGNAL lineDataOut4   : lc3b_word;
   SIGNAL lineDataOut5   : lc3b_word;
   SIGNAL lineDataOut6   : lc3b_word;
   SIGNAL lineDataOut7   : lc3b_word;
   SIGNAL lineSel        : std_logic_vector(7 DOWNTO 0);
   SIGNAL match          : std_logic;
   SIGNAL match1         : std_logic;
   SIGNAL offset         : lc3b_offset;
   SIGNAL preHit0        : std_logic;
   SIGNAL preHit1        : std_logic;
   SIGNAL protoHit       : std_logic;
   SIGNAL tag            : lc3b_tag;
   SIGNAL tagMuxOut      : lc3b_tag;
   SIGNAL tagOut0        : lc3b_tag;
   SIGNAL tagOut1        : lc3b_tag;
   SIGNAL validOut       : std_logic;
   SIGNAL validOut1      : std_logic;
   SIGNAL wAccess        : std_logic;
   SIGNAL wcData         : lc3b_oword;

   -- Implicit buffer signal declarations
   SIGNAL hit_internal : std_logic;


   -- Component Declarations
   COMPONENT ADDR_SPLITTER
   PORT (
      ADDRESS : IN     LC3b_word ;
      Index   : OUT    LC3b_index ;
      offset  : OUT    lc3b_offset ;
      tag     : OUT    lc3b_tag 
   );
   END COMPONENT;
   COMPONENT ANDgate
   PORT (
      a : IN     std_logic ;
      b : IN     std_logic ;
      f : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT ANDgate3
   PORT (
      a : IN     std_logic ;
      b : IN     std_logic ;
      c : IN     std_logic ;
      x : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT AddrJoiner
   PORT (
      Index     : IN     LC3b_index ;
      tagMuxOut : IN     lc3b_tag ;
      b         : OUT    LC3b_word 
   );
   END COMPONENT;
   COMPONENT DirtyMux
   PORT (
      dirtyOut0 : IN     std_logic ;
      dirtyOut1 : IN     std_logic ;
      dirty     : OUT    std_logic ;
      LRUOut    : IN     std_logic 
   );
   END COMPONENT;
   COMPONENT LRU
   PORT (
      LRUOut  : OUT    std_logic ;
      Index   : IN     LC3b_index ;
      preHit0 : IN     std_logic ;
      RESET_L : IN     std_logic ;
      hit     : IN     std_logic 
   );
   END COMPONENT;
   COMPONENT NANDgate2
   PORT (
      a : IN     std_logic ;
      b : IN     std_logic ;
      w : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT ORgate
   PORT (
      a : IN     std_logic ;
      b : IN     std_logic ;
      f : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT TagMux
   PORT (
      tagOut0   : IN     lc3b_tag ;
      tagOut1   : IN     lc3b_tag ;
      tagMuxOut : OUT    lc3b_tag ;
      LRUOut    : IN     std_logic 
   );
   END COMPONENT;
   COMPONENT WordMux2
   PORT (
      A   : IN     LC3b_word ;
      B   : IN     LC3b_word ;
      Sel : IN     std_logic ;
      F   : OUT    LC3b_word 
   );
   END COMPONENT;
   COMPONENT checkAccess
   PORT (
      MREAD_L   : IN     std_logic ;
      MWRITEH_L : IN     std_logic ;
      MWRITEL_L : IN     std_logic ;
      AccessOut : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT checkValid
   PORT (
      match    : IN     std_logic ;
      validOut : IN     std_logic ;
      preHit   : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT delay
   PORT (
      x : IN     std_logic ;
      f : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT delayClk
   PORT (
      Clk     : IN     std_logic ;
      hitgate : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT hitDetector
   PORT (
      AccessOut  : IN     std_logic ;
      in_idleHit : IN     std_logic ;
      protoHit   : IN     std_logic ;
      hitgate    : IN     std_logic ;
      hit        : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT lineJoiner
   PORT (
      lineDataOut1 : IN     lc3b_word ;
      lineDataOut2 : IN     lc3b_word ;
      lineDataOut3 : IN     lc3b_word ;
      lineDataOut4 : IN     lc3b_word ;
      lineDataOut5 : IN     lc3b_word ;
      lineDataOut6 : IN     lc3b_word ;
      lineDataOut7 : IN     lc3b_word ;
      lineDataOut0 : IN     lc3b_word ;
      wcData       : OUT    lc3b_oword 
   );
   END COMPONENT;
   COMPONENT lineSplitter
   PORT (
      line0          : OUT    lc3b_word ;
      line1          : OUT    lc3b_word ;
      line2          : OUT    lc3b_word ;
      line3          : OUT    lc3b_word ;
      line4          : OUT    lc3b_word ;
      line5          : OUT    lc3b_word ;
      line6          : OUT    lc3b_word ;
      line7          : OUT    lc3b_word ;
      WaySelecterOut : IN     LC3B_oWORD 
   );
   END COMPONENT;
   COMPONENT missDetector
   PORT (
      AccessOut : IN     std_logic ;
      f1        : IN     std_logic ;
      miss      : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT notGate
   PORT (
      A : IN     std_logic ;
      f : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT tagComparator
   PORT (
      addrTag  : IN     lc3b_tag ;
      cacheTag : IN     lc3b_tag ;
      match    : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT way
   PORT (
      DataWrite : IN     std_logic ;
      dataIn    : IN     lc3b_oword ;
      dirtyIn   : IN     std_logic ;
      index     : IN     lc3b_index ;
      reset_l   : IN     std_logic ;
      tagIn     : IN     lc3b_tag ;
      dataOut   : OUT    lc3b_oword ;
      dirtyOut  : OUT    std_logic ;
      tagOut    : OUT    lc3b_tag ;
      validOut  : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT waySelecter
   PORT (
      a   : IN     lc3b_oword ;
      b   : IN     lc3b_oword ;
      sel : IN     std_logic ;
      f   : OUT    lc3b_oword 
   );
   END COMPONENT;
   COMPONENT wordSelecter
   PORT (
      offset         : IN     lc3b_offset ;
      DATAIN         : OUT    lc3b_word ;
      WaySelecterOut : IN     LC3B_oWORD 
   );
   END COMPONENT;
   COMPONENT writeDecoder
   PORT (
      lineSel : OUT    std_logic_vector (7 DOWNTO 0);
      offset  : IN     lc3b_offset 
   );
   END COMPONENT;
   COMPONENT writer
   PORT (
      DataOut     : IN     lc3b_word ;
      decodeOut   : IN     std_logic ;
      lineData    : IN     lc3b_word ;
      mwriteh_l   : IN     std_logic ;
      mwritel_l   : IN     std_logic ;
      lineDataOut : OUT    lc3b_word 
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : ADDR_SPLITTER USE ENTITY ece411.ADDR_SPLITTER;
   FOR ALL : ANDgate USE ENTITY ece411.ANDgate;
   FOR ALL : ANDgate3 USE ENTITY ece411.ANDgate3;
   FOR ALL : AddrJoiner USE ENTITY ece411.AddrJoiner;
   FOR ALL : DirtyMux USE ENTITY ece411.DirtyMux;
   FOR ALL : LRU USE ENTITY ece411.LRU;
   FOR ALL : NANDgate2 USE ENTITY ece411.NANDgate2;
   FOR ALL : ORgate USE ENTITY ece411.ORgate;
   FOR ALL : TagMux USE ENTITY ece411.TagMux;
   FOR ALL : WordMux2 USE ENTITY ece411.WordMux2;
   FOR ALL : checkAccess USE ENTITY ece411.checkAccess;
   FOR ALL : checkValid USE ENTITY ece411.checkValid;
   FOR ALL : delay USE ENTITY ece411.delay;
   FOR ALL : delayClk USE ENTITY ece411.delayClk;
   FOR ALL : hitDetector USE ENTITY ece411.hitDetector;
   FOR ALL : lineJoiner USE ENTITY ece411.lineJoiner;
   FOR ALL : lineSplitter USE ENTITY ece411.lineSplitter;
   FOR ALL : missDetector USE ENTITY ece411.missDetector;
   FOR ALL : notGate USE ENTITY ece411.notGate;
   FOR ALL : tagComparator USE ENTITY ece411.tagComparator;
   FOR ALL : way USE ENTITY ece411.way;
   FOR ALL : waySelecter USE ENTITY ece411.waySelecter;
   FOR ALL : wordSelecter USE ENTITY ece411.wordSelecter;
   FOR ALL : writeDecoder USE ENTITY ece411.writeDecoder;
   FOR ALL : writer USE ENTITY ece411.writer;
   -- pragma synthesis_on


BEGIN

   -- Instance port mappings.
   addr_split : ADDR_SPLITTER
      PORT MAP (
         ADDRESS => ADDRESS,
         Index   => Index,
         offset  => offset,
         tag     => tag
      );
   way0write : ANDgate
      PORT MAP (
         a => f2,
         b => in_load,
         f => f3
      );
   way1Write : ANDgate
      PORT MAP (
         a => LRUOut,
         b => in_load,
         f => f4
      );
   ANDmrespH : ANDgate3
      PORT MAP (
         a => AccessOut,
         b => hit_internal,
         c => in_idleHit,
         x => MRESP_H
      );
   ditryWrite0 : ANDgate3
      PORT MAP (
         a => preHit0,
         b => wAccess,
         c => in_idleHit,
         x => dirtyWrite0
      );
   ditryWrite1 : ANDgate3
      PORT MAP (
         a => preHit1,
         b => wAccess,
         c => in_idleHit,
         x => dirtyWrite1
      );
   aAddrJoin : AddrJoiner
      PORT MAP (
         Index     => Index,
         tagMuxOut => tagMuxOut,
         b         => b
      );
   aDirtyMux : DirtyMux
      PORT MAP (
         dirtyOut0 => dirtyOut0,
         dirtyOut1 => dirtyOut1,
         dirty     => dirty,
         LRUOut    => LRUOut
      );
   aLRU : LRU
      PORT MAP (
         LRUOut  => LRUOut,
         Index   => Index,
         preHit0 => preHit0,
         RESET_L => RESET_L,
         hit     => hit_internal
      );
   aNANDgate : NANDgate2
      PORT MAP (
         a => MWRITEH_L,
         b => MWRITEL_L,
         w => wAccess
      );
   U_0 : ORgate
      PORT MAP (
         a => f4,
         b => dirtyWrite1,
         f => f6
      );
   U_1 : ORgate
      PORT MAP (
         a => dirtyWrite0,
         b => f3,
         f => f7
      );
   aORgate : ORgate
      PORT MAP (
         a => preHit0,
         b => preHit1,
         f => protoHit
      );
   aTagMux : TagMux
      PORT MAP (
         tagOut0   => tagOut0,
         tagOut1   => tagOut1,
         tagMuxOut => tagMuxOut,
         LRUOut    => LRUOut
      );
   AddrSelecter : WordMux2
      PORT MAP (
         A   => ADDRESS,
         B   => b,
         Sel => in_writeback,
         F   => PMADDRESS
      );
   aCheckAccess : checkAccess
      PORT MAP (
         MREAD_L   => MREAD_L,
         MWRITEH_L => MWRITEH_L,
         MWRITEL_L => MWRITEL_L,
         AccessOut => AccessOut
      );
   way0CheckV : checkValid
      PORT MAP (
         match    => match,
         validOut => validOut1,
         preHit   => preHit0
      );
   way1CheckV : checkValid
      PORT MAP (
         match    => match1,
         validOut => validOut,
         preHit   => preHit1
      );
   U_2 : delay
      PORT MAP (
         x => dirtyWrite0,
         f => dirtyIn0
      );
   U_3 : delay
      PORT MAP (
         x => dirtyWrite1,
         f => dirtyIn1
      );
   aDelay : delay
      PORT MAP (
         x => in_load,
         f => delayOut
      );
   dClk : delayClk
      PORT MAP (
         Clk     => Clk,
         hitgate => hitgate
      );
   aHit : hitDetector
      PORT MAP (
         AccessOut  => AccessOut,
         in_idleHit => in_idleHit,
         protoHit   => protoHit,
         hitgate    => hitgate,
         hit        => hit_internal
      );
   aLineJoiner : lineJoiner
      PORT MAP (
         lineDataOut1 => lineDataOut1,
         lineDataOut2 => lineDataOut2,
         lineDataOut3 => lineDataOut3,
         lineDataOut4 => lineDataOut4,
         lineDataOut5 => lineDataOut5,
         lineDataOut6 => lineDataOut6,
         lineDataOut7 => lineDataOut7,
         lineDataOut0 => lineDataOut0,
         wcData       => wcData
      );
   aLineSplitter : lineSplitter
      PORT MAP (
         line0          => line0,
         line1          => line1,
         line2          => line2,
         line3          => line3,
         line4          => line4,
         line5          => line5,
         line6          => line6,
         line7          => line7,
         WaySelecterOut => WaySelecterOut
      );
   aMiss : missDetector
      PORT MAP (
         AccessOut => AccessOut,
         f1        => f1,
         miss      => miss
      );
   notLRUout : notGate
      PORT MAP (
         A => LRUOut,
         f => f2
      );
   notProtoHit : notGate
      PORT MAP (
         A => protoHit,
         f => f1
      );
   way0TagComp : tagComparator
      PORT MAP (
         addrTag  => tag,
         cacheTag => tagOut0,
         match    => match
      );
   way1TagComp : tagComparator
      PORT MAP (
         addrTag  => tag,
         cacheTag => tagOut1,
         match    => match1
      );
   way0 : way
      PORT MAP (
         DataWrite => f7,
         dataIn    => f,
         dirtyIn   => dirtyIn0,
         index     => Index,
         reset_l   => RESET_L,
         tagIn     => tag,
         dataOut   => dataOut0,
         dirtyOut  => dirtyOut0,
         tagOut    => tagOut0,
         validOut  => validOut1
      );
   way1 : way
      PORT MAP (
         DataWrite => f6,
         dataIn    => f,
         dirtyIn   => dirtyIn1,
         index     => Index,
         reset_l   => RESET_L,
         tagIn     => tag,
         dataOut   => dataOut1,
         dirtyOut  => dirtyOut1,
         tagOut    => tagOut1,
         validOut  => validOut
      );
   aWaySelecter : waySelecter
      PORT MAP (
         a   => dataOut0,
         b   => dataOut1,
         sel => preHit1,
         f   => WaySelecterOut
      );
   evict : waySelecter
      PORT MAP (
         a   => dataOut0,
         b   => dataOut1,
         sel => LRUOut,
         f   => PMDATAOUT
      );
   wayDataSelect : waySelecter
      PORT MAP (
         a   => wcData,
         b   => PMDATAIN,
         sel => delayOut,
         f   => f
      );
   aWordSelecter : wordSelecter
      PORT MAP (
         offset         => offset,
         DATAIN         => DATAIN,
         WaySelecterOut => WaySelecterOut
      );
   aWriteDecode : writeDecoder
      PORT MAP (
         lineSel => lineSel,
         offset  => offset
      );
   write1 : writer
      PORT MAP (
         DataOut     => DATAOUT,
         decodeOut   => lineSel(1),
         lineData    => line1,
         mwriteh_l   => MWRITEH_L,
         mwritel_l   => MWRITEL_L,
         lineDataOut => lineDataOut1
      );
   writer0 : writer
      PORT MAP (
         DataOut     => DATAOUT,
         decodeOut   => lineSel(0),
         lineData    => line0,
         mwriteh_l   => MWRITEH_L,
         mwritel_l   => MWRITEL_L,
         lineDataOut => lineDataOut0
      );
   writer2 : writer
      PORT MAP (
         DataOut     => DATAOUT,
         decodeOut   => lineSel(2),
         lineData    => line2,
         mwriteh_l   => MWRITEH_L,
         mwritel_l   => MWRITEL_L,
         lineDataOut => lineDataOut2
      );
   writer3 : writer
      PORT MAP (
         DataOut     => DATAOUT,
         decodeOut   => lineSel(3),
         lineData    => line3,
         mwriteh_l   => MWRITEH_L,
         mwritel_l   => MWRITEL_L,
         lineDataOut => lineDataOut3
      );
   writer4 : writer
      PORT MAP (
         DataOut     => DATAOUT,
         decodeOut   => lineSel(4),
         lineData    => line4,
         mwriteh_l   => MWRITEH_L,
         mwritel_l   => MWRITEL_L,
         lineDataOut => lineDataOut4
      );
   writer5 : writer
      PORT MAP (
         DataOut     => DATAOUT,
         decodeOut   => lineSel(5),
         lineData    => line5,
         mwriteh_l   => MWRITEH_L,
         mwritel_l   => MWRITEL_L,
         lineDataOut => lineDataOut5
      );
   writer6 : writer
      PORT MAP (
         DataOut     => DATAOUT,
         decodeOut   => lineSel(6),
         lineData    => line6,
         mwriteh_l   => MWRITEH_L,
         mwritel_l   => MWRITEL_L,
         lineDataOut => lineDataOut6
      );
   writer7 : writer
      PORT MAP (
         DataOut     => DATAOUT,
         decodeOut   => lineSel(7),
         lineData    => line7,
         mwriteh_l   => MWRITEH_L,
         mwritel_l   => MWRITEL_L,
         lineDataOut => lineDataOut7
      );

   -- Implicit buffered output assignments
   hit <= hit_internal;

END struct;
